
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Weekly Pages</title>
  <style>
    body {
      font-family: Georgia, serif;
      margin: 2em;
      line-height: 1.6;
      background-color: #f9f9f9;
      color: #333;
    }

    header {
      background: #fff;
      padding: 1em 2em;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #ccc;
      position: relative;
    }

    h1 {
      margin: 0;
      font-size: 2em;
      color: #2c3e50;
    }

    /* Elegant nav links */
    nav {
      display: flex;
      gap: 1em;
    }

    nav a {
      color: #2c3e50;
      background: transparent;
      padding: 0.3em 0.6em;
      text-decoration: none;
      border-radius: 3px;
      font-size: 1em;
      transition: background-color 0.3s ease, color 0.3s ease;
      border: none;
      font-weight: 500;
    }

    nav a:hover,
    nav a:focus {
      background-color: #2c3e50;
      color: white;
      outline: none;
      cursor: pointer;
    }

    /* Dropdown container hidden by default */
    .dropdown {
      display: none;
      position: relative;
    }

    /* Dropdown button style */
    .dropdown-button {
      background: transparent;
      border: none;
      font-size: 1.2em;
      cursor: pointer;
      color: #2c3e50;
      padding: 0.3em 0.6em;
      border-radius: 3px;
      font-weight: 500;
    }

    .dropdown-button:hover,
    .dropdown-button:focus {
      background-color: #2c3e50;
      color: white;
      outline: none;
    }

    /* Dropdown menu */
    .dropdown-menu {
      display: none;
      position: absolute;
      right: 0;
      top: 100%;
      background: white;
      border: 1px solid #ccc;
      border-radius: 4px;
      margin-top: 0.3em;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      min-width: 120px;
      z-index: 10;
    }

    .dropdown-menu a {
      display: block;
      padding: 0.5em 1em;
      color: #2c3e50;
      text-decoration: none;
      font-weight: 400;
      border-bottom: 1px solid #eee;
    }

    .dropdown-menu a:last-child {
      border-bottom: none;
    }

    .dropdown-menu a:hover,
    .dropdown-menu a:focus {
      background-color: #2c3e50;
      color: white;
      outline: none;
    }

    /* Show dropdown menu when active */
    .dropdown.open .dropdown-menu {
      display: block;
    }

    /* Responsive behavior */
    @media (max-width: 600px) {
      nav {
        display: none;
      }
      .dropdown {
        display: block;
      }
    }

    main {
      padding: 2em;
    }

    footer {
      background: #f1f1f1;
      text-align: center;
      padding: 1em;
      margin-top: 2em;
    }

    h2 {
      color: #2c3e50;
    }

    img {
      height: auto;
      margin: 1em 0;
      display: block;
      margin-left: auto;
      margin-right: auto;
      max-width: 50%;
    }

    .limited-size {
      max-width: 400px;
      width: 100%;
    }

    .figure {
      text-align: center;
      margin-bottom: 2em;
    }

    .figure-caption {
      font-style: italic;
      color: #555;
    }

    code {
      background-color: #eee;
      padding: 0.2em 0.4em;
      border-radius: 3px;
    }
  </style>
</head>
<body>
  <header>
    <h1>Hannah's Weekly Notes</h1>

      <a href="index.html">Week 1</a>
      <a href="week2.html">Week 2</a>
      <a href="week3.html">Week 3</a>
      <a href="week4.html">Week 4</a>
      <a href="week5.html">Week 5</a>
      <a href="week6.html">Week 6</a>
      <a href="week7.html">Week 7</a>
      <!-- Add more as needed -->
    </nav>

    <div class="dropdown" aria-haspopup="true" aria-expanded="false">
      <button class="dropdown-button" aria-label="Open navigation menu">☰</button>
      <div class="dropdown-menu" role="menu" aria-label="Navigation menu">
        <a href="index.html" role="menuitem">Week 1</a>
        <a href="week2.html" role="menuitem">Week 2</a>
        <a href="week3.html" role="menuitem">Week 3</a>
        <a href="week4.html" role="menuitem">Week 4</a>
        <a href="week5.html" role="menuitem">Week 5</a>
        <a href="week6.html" role="menuitem">Week 6</a>
        <a href="week7.html" role="menuitem">Week 7</a>
        <!-- Add more as needed -->
      </div>
    </div>
    </div>
  </header>

  <main>

  <p>
    With a working model implemented with brownian bridge, the start of this week had a focus on formatting and code cleaning. Tasks that got completed:
  </p>

  <p>
   1) Writing unit tests.
  </p>
  <p>
   2) Writing code to pipeline the fetching of feature data from google earth engine. Before I was downloading the dataset manually for the areas, but this pipeline gets the relevant area to combine the data into a table with my calculated ranger data. In order to make this data compatible with my code I adjusted my code so it produced pixel grids measured in metres (not degrees). 
  </p>

  <p>Now that I have all the data, I started to think about how it is being formatted for training the model. I need to consider both the resolution of the map, and the train/test split. The best resolution that all of the features from google earth engine can be downloaded at is 90m. Something I wanted to investigate is how the percentage of data points that are labelled with a path/value changes with resolution (as shown in the figure below).</p>

  <div class="figure">
    <img src="graphs/highlighted_resolutions.png" class="limited-size">
  </div>

  <p>The highlighted area is the data that can be used for training/ testing our model. I don't believe it is something that should guide our decision too much, but I was interested to see how it would look.</p>
  <div class="figure">
    <img src="graphs/resolution_coverage.png" class="limited-size">
  </div>

  <p>At my chosen resolution of 90m, about ~15 percent of my land area is labelled.</p>

  <p>Now onto the main point I am deliberating over….</p>

  <h3>Train/Test split</h3>
  <div class="figure">
    <img src="graphs/train_test_split.png" class="limited-size">
  </div>

  <p>Method 1 suffers from autocorrelation. model will be overly-optimistic in it's success</p>
  <p>Method 2 does not suffer from autocorrelation as much, but maybe not representative in it's training or testing</p>

   <p>To balance both of these ideas, I looked into the idea of creating blocks (formed from many pixels) of train and test data. The figure below has blocks of 2 x 2, but they could be much larger.</p>

  <div class="figure">
    <img src="graphs/blocking.png" class="limited-size">
  </div>

  <p>This helps reduce how much the training data is correlated with the test data—but by how much? I would assume that the larger the block size, the lower the correlation between train and test, but at some point this suffers from the same problem as ‘method 2’. I want to know the ideal block size, and if this is a valid method. I’m not really sure how to approach this currently, and have been struggling to find an answer in the literature, but i start by looking at morans I</p>

  <p>Moran’s I calculates the spatial autocorrelation by measuring the covariance of values across space, weighted by how close locations are. You compare this to what you’d expect if the data were randomly distributed, and test for significance.</p>
  
  <p>I ran Moran’s I on the rangers’ speed data. An important detail here is that many pixels have no recorded speed, since the rangers never traveled through them. Because Moran’s I cannot handle null values, I set these pixels to zero. To avoid bias from treating “no data” as actual speed, I tested significance by shuffling only the non-zero values. In other words, testing for spatial autocorrelation of speed only <b>within</b> the known data.</p> 

  <p>I want to know how the spatial autocorrelation is affected by block size. I tried investigating this by taking the average speed for each block (a square chunk of pixels) and found the autocorrelation between these averaged values. I did this for different block sizes, and marked which were significant.</p>
  <p>The graph below shows Moran’s I calculated for blocks of different sizes. Each block is defined as 2^n pixels in both width and height, with each pixel representing 10 m × 10 m. This is different from the 90 m resolution mentioned earlier, but here I wanted to test autocorrelation across a whole range of scales. At the largest block size, 2048 × 2048 pixels, the area covered is roughly 20 km across.</p>
  <div class="figure">
    <img src="graphs/mor_i.png" class="limited-size">
  </div>
    
  <p>I’m not sure this is the correct way of doing things, and need to go into further research next week. It is intended to show the autocorrelation between blocks, but doesn't say anything about the autocorrelation within blocks. This within-block autocorrelation still poses an issue and will affect the model, but the between-block autocorrelation is what causes the correlation between train and test data. This is what would make the model look too optimistic. I believe that if I pick a block size that does not show significance in the between-block spatial autocorrelation, then I can at least trust the evaluation of my model.</p>
  <script>
  document.addEventListener('DOMContentLoaded', function () {
    const dropdown = document.querySelector('.dropdown');
    const button = dropdown.querySelector('.dropdown-button');

    button.addEventListener('click', function (e) {
      e.stopPropagation(); // Prevent bubbling to document
      dropdown.classList.toggle('open');
      const expanded = dropdown.classList.contains('open');
      button.setAttribute('aria-expanded', expanded);
    });

    document.addEventListener('click', function (e) {
      if (!dropdown.contains(e.target)) {
        dropdown.classList.remove('open');
        button.setAttribute('aria-expanded', false);
      }
    });
  });
</script>

</body>
</html>
